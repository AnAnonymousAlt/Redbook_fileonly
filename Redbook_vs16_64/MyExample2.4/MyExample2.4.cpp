// My Example2.4 from Redbook
#ifndef _GL_DEF

#include <GL/gl3w.h>
#include <GLFW/glfw3.h>

#define _GL_DEF
#endif // !_GL_DEF

#include <helper_functions.h>
#include <cstdio>



enum VAO_ID
{
	Triangles, numVAOs
};

enum Buffer_ID
{
	ArrayBuffer, UniformBuffer, numBuffers
};

enum ATTRIB_ID
{
	vPosition = 0
};

GLuint VAOs[numVAOs];
GLuint buffers[numBuffers];

const GLint numVertices = 3;


/// <summary>
/// My init
/// </summary>
void
init ()
{
	glClearColor ( 0.1f, 0.0f, 0.0f, 1.0f );

	const GLfloat vertices[numVertices][2] =
	{
		{ -0.5f, -0.5f },
		{  0.0f, -0.5f },
		{ -0.5f,  0.0f }
	};

	glCreateVertexArrays ( numVAOs, VAOs );
	glCreateBuffers ( numBuffers, buffers );


	GLuint program = glCreateProgram ();
	loadShader ( program );
	
	GLvoid *uboBuffer;


	// Allocate uniform buffer
	{
		// Initialize uniform values in uniform block "myUniform"
		GLuint uboIndex;
		GLint uboSize;

		// The first step in initializing the uniform variables in uniform block is to obtain the index of the block for a given program
		// The name is necessary here
		uboIndex = glGetUniformBlockIndex ( program, "myUniform" );
		// Then use the index to determine the uniform block's size
		// This function returns the size generated by compiler
		glGetActiveUniformBlockiv ( program, uboIndex, GL_UNIFORM_BLOCK_DATA_SIZE, &uboSize );

		// Malloc the buffer with the size of the block
		uboBuffer = malloc ( uboSize );

		// error checking
		if ( uboBuffer == NULL )
		{
			fprintf ( stderr, "Unable to allocate buffer\n" );
			exit ( EXIT_FAILURE );
		}

		// index and numbers of the variables in block
		enum
		{
			Blue, Enabled, Green, Movement, Red, NumUniforms
		};

		/* Values to be stored in the buffer object */
		GLfloat blue = 0.0f;
		// Don't know why boolean doesn't work
		GLfloat enabled = 0.0f;
		GLfloat green = 0.0f;
		GLfloat movement = 0.0f;
		GLfloat red = 0.0f;


		/* Since we know the names of the uniforms
		** in our block, make an array of those values' name */
		// glsl compiler use alphabet to sort variables
		const char *names[NumUniforms] =
		{
			"blue",
			"enabled",
			"green",
			"movement",
			"red"
		};
		 
		/* Query the necessary attributes to determine
		** where in the buffer we should write
		** the values */
		GLuint indices[NumUniforms];
		GLint size[NumUniforms];
		GLint offset[NumUniforms];
		GLint type[NumUniforms];

		// Use names to retrive inforamation of the variables in uniform
		// Get indices for each variable
		glGetUniformIndices ( program, NumUniforms, names, indices );
		// Get sizes
		glGetActiveUniformsiv ( program, NumUniforms, indices,
								GL_UNIFORM_SIZE, size );
		// Get offsets
		glGetActiveUniformsiv ( program, NumUniforms, indices,
								GL_UNIFORM_OFFSET, offset );
		//Get types
		glGetActiveUniformsiv ( program, NumUniforms, indices,
								GL_UNIFORM_TYPE, type );

		// Clear memory before copy
		memset ( uboBuffer, 0, uboSize );
		// Copy variables' value into the buffer 
		memcpy ( ( char * ) uboBuffer + offset[Red], &red,
				 size[Red] * typeSize ( type[Red] ) );
		memcpy ( ( char * ) uboBuffer + offset[Green], &green,
				 size[Green] * typeSize ( type[Green] ) );
		memcpy ( ( char * ) uboBuffer + offset[Blue], &blue,
				 size[Blue] * typeSize ( type[Blue] ) );
		memcpy ( ( char * ) uboBuffer + offset[Movement], &movement,
				 size[Movement] * typeSize ( type[Movement] ) );
		// typeSize (type[boolean]) == 1
		// If write as the book, memcpy only copy 1 byte, makes it 00 xx xx xx
		// then shader always read true
		// so we have to clear the buffer before assigning value to it
		// add memset before memcpy
		memcpy ( ( char * ) uboBuffer + offset[Enabled], &enabled,
				 size[Enabled] * typeSize ( type[Enabled] ) );

		/* Create the uniform buffer object,
		** initialize its storage, and associated
		** it with the shader program */
		glNamedBufferStorage ( buffers[UniformBuffer], uboSize, uboBuffer, 0 );
		// Bind the buffer to uniform buffer
		glBindBuffer ( GL_UNIFORM_BUFFER, buffers[UniformBuffer] );
		// Associate a buffer object with the block using the block's index
		glBindBufferBase ( GL_UNIFORM_BUFFER, uboIndex, buffers[UniformBuffer] );
	}

	glNamedBufferStorage ( buffers[ArrayBuffer], sizeof ( vertices ),
						   &vertices, 0 );
	glBindVertexArray ( VAOs[Triangles] );
	glBindBuffer ( GL_ARRAY_BUFFER, buffers[ArrayBuffer] );
	glVertexAttribPointer ( vPosition, 2, GL_FLOAT, GL_FALSE, 0,
							( void * ) 0 );
	glEnableVertexAttribArray ( vPosition );
}

void
display ()
{
	glClear ( GL_COLOR_BUFFER_BIT );
	glDrawArrays ( GL_TRIANGLES, 0, numVertices );
}

int
main ( int argc, char **argv )
{
	glfwInit ();

	GLFWwindow *window = glfwCreateWindow ( 640, 480, "Triangle", NULL, NULL );

	glfwMakeContextCurrent ( window );
	gl3wInit ();

	init ();

	while ( !glfwWindowShouldClose ( window ) )
	{
		display ();
		glfwSwapBuffers ( window );
		glfwPollEvents ();
	}

	glfwDestroyWindow ( window );
	glfwTerminate ();
	return 0;
}

